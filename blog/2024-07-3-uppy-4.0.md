---
title:
  'New Uppy 4.0 major: TypeScript rewrite, Google Photos, React hooks, and much
  more.'
date: 2024-07-03
authors: [aduh95, evgenia, mifi, murderlon]
image: 'https://uppy.io/img/blog/3.13-3.21/dog-coding-laptop-mars-christmas-tree-2.jpg'
slug: 'uppy-4.0'
published: false
toc_max_heading_level: 2
---

Hi ha ho, this is some goofy introduction.

## TypeScript rewrite

In the year 2024 people expect exellent types from their libaries. We used to
author types separately by hand but they were often inconsistent or incomplete.
Now Uppy has been completely rewritten in TypeScript!

From now on you’ll be in safe hands when working with Uppy, whether it’s setting
the right options, building plugins, or listening to events.

```ts
import Uppy from '@uppy/core';

const uppy = new Uppy();

// Event name autocompletion and inferred argument types
uppy.on('file-added', (file) => {
	console.log(file);
});
```

One important thing to note are the new generics on `@uppy/core`.

```ts
import Uppy from '@uppy/core';
// xhr-upload is for uploading to your own backend.
import XHRUpload from '@uppy/xhr-upload';

// Your own metadata on files
type Meta = { myCustomMetadata: string };
// The response from your server
type Body = { someThingMyBackendReturns: string };

const uppy = new Uppy<Meta, Body>().use(XHRUpload, {
	endpoint: '/upload',
});

const id = uppy.addFile({
	name: 'example.jpg',
	data: new Blob(),
	meta: { myCustomMetadata: 'foo' },
});

// This is now typed
const { myCustomMetadata } = uppy.getFile(id).meta;

await uppy.upload();

// This is strictly typed too
const { someThingMyBackendReturns } = uppy.getFile(id).response;
```

Happy inferring!

## Merging the two AWS S3 plugins

We used to two separate plugins for uploading to S3 (and S3-compatible
services): `@uppy/aws-s3` and `@uppy/aws-s3-multpart`. They have different use
cases. The advantages of multipart uploads are:

- Improved throughput – You can upload parts in parallel to improve throughput.
- Quick recovery from any network issues – Smaller part size minimizes the
  impact of restarting a failed upload due to a network error.
- Pause and resume object uploads – You can upload object parts over time. After
  you initiate a multipart upload, there is no expiry; you must explicitly
  complete or stop the multipart upload.
- Begin an upload before you know the final object size – You can upload an
  object as you are creating it.

However, the downside is request overhead, as it needs to do creation, signing,
and completion requests besides the upload requests. For example, if you are
uploading files that are only a couple kilobytes with a 100ms roundtrip latency,
you are spending 400ms on overhead and only a few milliseconds on uploading.
This really adds up if you upload a lot of small files.

AWS, and generally the internet from what we found, tend to agree that **you
don't want to use multipart uploads for files under 100MB**. But this sometimes
puts users of our libraries in an awkward position, as their end users may not
only upload very large files, or only small files. In this case a portion of
their users get a subpar experience.

---

<!-- TODO: /aws-s3-multipart link should be /aws-s3 (needs site changes) -->

We’ve merged the two plugins into `@uppy/aws-s3` with a new
[`shouldUseMultipart`](/docs/aws-s3-multipart/#shouldusemultipartfile) option!
By default it switches to multipart uploads if the file is larger than 100MB.
You can pass a `boolean` or a function to determine it per file.

## React hooks

People working with React are more likely to create their own user interface on
top of Uppy than those working with "vanilla" setups. Working with our pre-build
UI components is a plug-and-play experience, but building on top of Uppy’s state
with React primitives has been tedious.

To address this we’re introducing to new hooks: `useUppyState` and
`useUppyEvent`. Thanks to the TypeScript rewrite, we can now do powerful
inference in hooks as well.

### `useUppyState(uppy, selector)`

Use this hook when you need to access Uppy’s state reactively.

```js
import Uppy from '@uppy/core';
import { useUppyState } from '@uppy/react';

// IMPORTANT: passing an initializer function to prevent Uppy from being reinstantiated on every render.
const [uppy] = useState(() => new Uppy());

const files = useUppyState(uppy, (state) => state.files);
const totalProgress = useUppyState(uppy, (state) => state.totalProgress);
// We can also get specific plugin state.
// Note that the value on `plugins` depends on the `id` of the plugin.
const metaFields = useUppyState(
	uppy,
	(state) => state.plugins?.Dashboard?.metaFields,
);
```

<!-- TODO: this permalink to State will get outdated. Maybe put it in a file we can link to? -->

You can see all the values you can access on the
[`State`](https://github.com/transloadit/uppy/blob/dab8082a4e67c3e7f109eacfbd6c3185f117dc60/packages/%40uppy/core/src/Uppy.ts#L156)
type. If you are accessing plugin state, you would have to look at the types of
the plugin.

### `useUppyEvent(uppy, event, callback)`

Listen to Uppy [events](/docs/uppy/#events) in a React component.

Returns an array of which the first item is an array of results from the event.
Depending on the event, that can be empty or have up to three values. The second
item is a function to clear the results.

Values remain in state until the next event (if that ever comes). Depending on
your use case, you may want to keep the values in state or clear the state after
something else happened.

```ts
import Uppy from '@uppy/core';
import { useUppyEvent } from '@uppy/react';

// IMPORTANT: passing an initializer function
// to prevent Uppy from being recreated on every render.
const [uppy] = useState(() => new Uppy());

const [results, clearResults] = useUppyEvent(uppy, 'transloadit:result');
const [stepName, result, assembly] = results; // strongly typed

useUppyEvent(uppy, 'cancel-all', doSomethingElse);
```

## Google Photos

A long requested feature is finally here: Google Photos support!

:::info

Uppy can bring in files from the cloud with [Companion](/docs/companion/).

Companion is a hosted, standalone, or middleware server to take away the
complexity of authentication and the cost of downloading files from remote
sources, such as Instagram, Google Drive, and others.

This means a 5GB video isn’t eating into your users’ data plans and you don’t
have to worry about OAuth.

:::

<!-- TODO: video of the Google Photos plugin -->

[`@uppy/google-photos`](/docs/google-photos/) is a new plugin so you can use it
next to your existing [`@uppy/google-drive`](/docs/google-drive/) plugin.

## UX improvements for viewing remote files

When using [Dashboard](/docs/dashboard) with any of our remote sources (
Google Drive, Facebook, etc.) you use our internal `@uppy/provider-views` plugin to navigate and
select files. In Uppy 4.0, we are making a handful of quality of life improvements for users.  
We describe the main changes in a table below.

<table style="text-align:left; font-size: 15px">
  <tbody>
    <tr>
      <td colspan="2">
        <b style="font-size: 17px;">Folder states: checked, unchecked, partial</b>
        <p style="margin-bottom: 0;">In 4.0, we introduce a new folder state - a "partially checked" folder. A folder acquires this state when some files within the folder are "checked", and some files are "unchecked".</p>
      </td>
    </tr>
    <tr>
      <th style="padding-top: 0; padding-bottom: 0;">PREVIOUSLY</th>
      <th style="padding-top: 0; padding-bottom: 0;">NOW</th>
    </tr>
    <tr>
      <td style="width: 50%;"><video src="/img/blog/4.0/partial-old.mov" controls></video></td>
      <td style="width: 50%;"><video src="/img/blog/4.0/partial-new.mov" controls></video></td>
    </tr>
    <tr>
      <td colspan="2">
        <b style="font-size: 17px;">Cache</b>
        <p style="margin-bottom: 0;">When navigating in and out of folders, you no longer have to wait for the same API call — results get cached.</p>
      </td>
    </tr>
    <tr>
      <th style="padding-top: 0; padding-bottom: 0;">PREVIOUSLY</th>
      <th style="padding-top: 0; padding-bottom: 0;">NOW</th>
    </tr>
    <tr>
      <td style="width: 50%;"><video src="/img/blog/4.0/cache-old.mov" controls></video></td>
      <td style="width: 50%;"><video src="/img/blog/4.0/cache-new.mov" controls></video></td>
    </tr>
    <tr>
      <td colspan="2">
        <b style="font-size: 17px;">Restrictions</b>
        <p style="margin-bottom: 0;">
          Uppy supports file <a href="/docs/uppy/#restrictions">restrictions</a>, such as max number of files and max file size. In 4.0, we reworked our restrictions UI - users will get immediate feedback upon exceeding the number of selected files, and users get a chance to reenter the correct number of files after their first upload attempt.
        </p>
      </td>
    </tr>
    <tr>
      <th style="padding-top: 0; padding-bottom: 0;">PREVIOUSLY</th>
      <th style="padding-top: 0; padding-bottom: 0;">NOW</th>
    </tr>
    <tr>
      <td style="width: 50%;"><video src="/img/blog/4.0/restrictions-old.mov" controls></video></td>
      <td style="width: 50%;"><video src="/img/blog/4.0/restrictions-new.mov" controls></video></td>
    </tr>
  </tbody>
</table>

We’re confident this turns our interface for remote sources into the most
advanced one out there. We’ve seen some competing libraries not even aggregating
results beyond the first page API limit of providers.

## Revamped options for `@uppy/xhr-upload`

## Simpler configuration for `@uppy/transloadit`

## Companion

## And more

The 4.0 release contained over 170 contributions, many too small to mention, but
together resulting in Uppy continuing to grow and improve. We closely listen to
the community and are always looking for ways to improve the experience.

Since our last blog post other (non-breaking) changes have also been released.
